<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
    <title>Microphone testing</title>
    <script type="text/javascript">
      let webaudio_tooling_obj = () => {
        let audioContext = new AudioContext();

        // console.log("audio is starting up");

        const BUFF_SIZE_RENDERER = 16384;

        let audioInput = null,
        microphone_stream = null,
        gain_node = null,
        script_processor_node = null,
        script_processor_analysis_node = null,
        analyser_node = null;

        let show_some_data = (given_typed_array, num_row_to_display, label) => {
          let size_buffer = given_typed_array.length;
          let index = 0;

          // console.log("___________" + label);

          if(label === "time") {
            for(; index < num_row_to_display && index < size_buffer; index += 1) {
              let curr_value_time = (given_typed_array[index] / 128) - 1.0;
              // console.log(curr_value_time);
            }
          } else if(label === "frequency") {
            for(; index < num_row_to_display && index < size_buffer; index += 1) {
              // console.log(given_typed_array[index]);
            }
          } else {
            throw new Error("Error - must pass time or frequency");
          }
        };

        let process_microphone_buffer = (event) => {
          //calculate the inverse of the sound waves here!!!
          let microphone_input_buffer = event.inputBuffer.getChannelData(0);
          let microphone_output_buffer = event.outputBuffer.getChannelData(0);
          for(let i = 0; i < microphone_input_buffer.length; i++) {
            microphone_output_buffer[i] = -1 * microphone_input_buffer[i];
          }
        }

        let start_microphone = (stream) => {
          gain_node = audioContext.createGain();
          gain_node.connect(audioContext.destination);

          microphone_stream = audioContext.createMediaStreamSource(stream);
          microphone_stream.connect(gain_node);

          script_processor_node = audioContext.createScriptProcessor(BUFF_SIZE_RENDERER, 1, 1);
          script_processor_node.onaudioprocess = (event) => {
            //calculate the inverse of the sound waves here!!!
            let microphone_input_buffer = event.inputBuffer.getChannelData(0);
            let microphone_output_buffer = event.outputBuffer.getChannelData(0);
            for(let i = 0; i < microphone_input_buffer.length; i++) {
              microphone_output_buffer[i] = -1 * microphone_input_buffer[i];
            }
          };

          microphone_stream.connect(script_processor_node);
          script_processor_node.connect(audioContext.destination);

          let x = document.getElementById("volume");
          x.addEventListener("change", () => {
            let curr_volume = x.value;
            gain_node.gain.value = curr_volume;
            // console.log("curr_volume", curr_volume);
          });

          script_processor_analysis_node = audioContext.createScriptProcessor(2048, 1, 1);
          script_processor_analysis_node.connect(gain_node);

          analyser_node = audioContext.createAnalyser();
          analyser_node.smoothingTimeConstant = 0;
          analyser_node.fftSize = 2048;

          microphone_stream.connect(analyser_node);
          analyser_node.connect(script_processor_analysis_node);

          let buffer_length = analyser_node.frequencyBinCount;
          let array_freq_domain = new Uint8Array(buffer_length);
          let array_time_domain = new Uint8Array(buffer_length);

          // console.log("buffer_length " + buffer_length);

          script_processor_analysis_node.onaudioprocess = () => {
            analyser_node.getByteFrequencyData(array_freq_domain);
            analyser_node.getByteTimeDomainData(array_time_domain);

            // if(microphone_stream.playbackState == microphone_stream.PLAYING_STATE) {
            //   show_some_data(array_freq_domain, 5, "frequency");
            //   show_some_data(array_time_domain, 5, "time");
            // }
          };
        };
        if(!navigator.getUserMedia) {
          navigator.getUserMedia = navigator.getUserMedia
                              || navigator.webkitGetUserMedia
                              || navigator.mozGetUserMedia
                              || navigator.msGetUserMedia;
        }

        if(navigator.getUserMedia) {
          navigator.getUserMedia({audio:true},
          (stream) => {
            start_microphone(stream);
          },
          (e) => {
            alert('Error capturing audio.');
          });
        } else {
          alert('getUserMedia not supported in this browser.');
        }
      };
      webaudio_tooling_obj();
    </script>
  </head>
  <body>
    <p>Volume</p>
    <input id="volume" type="range" min="0" max="1" step="0.1" value="0.5"/>
  </body>
</html>
